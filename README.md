# Stock Price Sqlite Database API
* [Instillation Instructions](https://github.com/MatthewTe/stockprice_database_api#instillation-instructions)
* [Price Database API](https://github.com/MatthewTe/stockprice_database_api#price-database-api)

## Intro
This is a package containing an api for creating/maintaining and interacting with a sqlite database containing price time series data on public stocks. This api mainly serves as a python wrapper for the [`yfinance`](https://pypi.org/project/yfinance/) api which in turn interacts with the Yahoo Finance stock web api (have I met my contractual obligation to use the word api as much as possible yet?).

## Instillation Instructions
This package is relatively straightforward to install. It can be installed via pip. All of the dependencies should be automatically installed however if not they can be installed manually:
```
pip install yfinance
pip install pandas
```

## Price Database API
The script `pricedb_api.py` contains the main method `price_db_api` which contains all the api's necessary to interact with the price database.

### `price_db_api(db_path)`
This is the main object that connects to the database. All subsequent methods require that this method be initialized with the path of the sqlite database file input as a string.

Once initialized, if the sqlite file does not exits it is created and then the `Summary` table is created and written to the database if it does not already exist:
|Ticker|Last_updated|
|------|------------|
|TEXT  | TEXT       |

This is the table that records all the ticker tables that are present in the database and the last time that each table has been updated. `Summary` table is modified/written to in most of the database writing methods.

### `update_ticker(self, ticker)`
This is the method that writes/updates time series price data of a specific ticker. Once the method is called and the ticker string input is valid, if a table does not already exist, a table for the ticker is created with the naming convention `{ticker}_timeseries` with the following schema:

|Date|Open|High|Low |Close|Volume |Dividends|Stock_Splits|
|----|----|----|----|-----|-------|---------|------------|
|TEXT|REAL|REAL|REAL|REAL |INTEGER|REAL     |REAL        |

The `yfinance` `Ticker` object is then initialized with the ticker string and is written to the database into the format of the table above. This timeseries price data generated by the Yahoo Finance web api is written to the database via the pandas sql api:
```python
# Writing dataframe to database:
df.to_sql(ticker_table, con=self.con, if_exists = 'replace')

```
The price data is written to the timeseries price data with the `if_exists` parameter set to `'replace'`. This means that ever time this method is called it replaces the data in the database table completely with a dataframe containing the most recent price data. This is a very brute force means of updating data in the database and is reasonable in this context due to the low performance requirements necessary to write ticker timeseries dataframes.

The method when called also calls the `update_timeseries_technicals()` method with the same `ticker` parameter which builds a dataframe of technical data derived from the price timeseries in the database. This technical data is described below and is written to the database using the same pandas sql api with the `if_exists` parameter set to `'replace'`:

```python
# Writing dataframe to database:
df.to_sql(ticker_table, con=self.con, if_exists = 'replace')

# Debug print:
print(f'[WRITTEN]: {ticker} Timeseries')

# Executing the update_timeseries_technicals() method to write technical
# data to the database:
self.update_timeseries_technicals(ticker)

# Updating/Writing data to the Summary Data table:
self.c.execute(
    """INSERT OR REPLACE INTO Summary (Ticker, Last_updated)
    VALUES (:ticker, :Last_updated)""",
    {'ticker':ticker, 'Last_updated': datetime.now().date()})
```
The method then writes meta data about the ticker and their time of last update to the `Summary` table as described previously.

In all the database operations performed by this method are: **1 Read and 3 Writes.** This read and write inefficiency is only implement due to the low computational requirements of these processes. This method of brute force bulk replacements of tables would not be realistic if the data being read and written was more complex or computationally intensive.

### `update_timeseries_technicals(self, ticker)`
This is the method that is used to calculate and write technical indicators of a ticker's price timeseries to the database.

This technical indicators that this method calculates and writes to the database are:
- 1-Month Annualized Historical Volatility
- 3-Months Annualized Historical Volatility
- 12-Day SMA & EMA
- 26-Day SMA & EMA
- 50-Day SMA & EMA
- 200-Day SMA & EMA
- MACD Value
- RSI

The method begins by creating the database table, if it does not exist, with columns according to the list of indicators above as `'{ticker}_technicals'`. Once the table is created, or determined to exist, the method then queries the database for the historical price timeseries for the input `ticker` parameter using pandas sql api:

```python
price_df = pd.read_sql_query(f"SELECT * FROM {ticker}_timeseries", con = self.con)
```
The `Close` price series is extracted from the price_df and used to build a dataframe of timeseries technical indicators listed above. This new dataframe is then written to the database table `'{ticker}_technicals'` via the pandas sql api:

```python
# Writing the technicals dataframe to the database:
technical_df.to_sql(table_name, con=self.con, if_exists='replace')
```

The pandas sql api parameter `if_exists` is set to `replace` so, much like the `update_ticker()` method, the database is updated with the most recent values by dropping and replacing the data from the database. Once again this is a bulk and brute force method of updating the database.

### `update_tickers(self, ticker_lst)`
This method is just an iterative wrapper over the earlier `update_ticker()` method. In ingests a list of ticker strings and for each ticker string calls the `update_ticker()` method with all of its subsequent logic and table update handling.

### `maintain_db(self)`
This method is used to maintain an existing database. It extracts a list of ticker strings from the database's `Summary` table and calls the `update_tickers()` with this ticker list. This updates all tickers within the list using the `update_ticker()` method. Which is the main method for updating data tables related to a single ticker.

This is more of a "helper" method however it is placed in the "Database Writer" category as it technically does write data to the database.

### `get_table(self, table_name)`
This is a brute force query method. It queries the database using the `pandas.read_sql_query()` method to return a dataframe of the table specified by the `table_name` parameter. If there is no table in the database with the name specified by `table_name` then it returns a None object.

Example:
```python
# Initializing connection to database:
test = price_db_api('path_to_sqlite_database')

# Calling the timeseries price data for Exxon:
test.get_table('XOM_timeseries')

# Calling the Summary table:
test.get_table('Summary')
```  

### `get_ticker_data(self, ticker, start_date=None, end_date=None):`
This is a query method that is intended to be used to specifically query timeseries and technical data for a stock from the database (basically all data in this database except for the `Summary` table associated with a ticker).

It does this by wrapping the previously used `pandas.read_sql_query()` method in logic that only requires the input of the ticker symbol with optional start and end date values that modify what timeseries and technical data is read from the database.

It should be noted that specifying a specific date time does not reduce read times from the database as the method extracts the entire ticker timeseries and technical data tables, converts the `Date` value to `datetime` objects and then uses those date time objects to slice the entire dataframes into the dataframes specified by the `start_date` and `end_date` values. In other words it is irrelevant either or not dates are specified as a bulk data query is being executed either way.

The method returns a two key dictionary: `{'price': ticker_timeseries_df, 'technicals': ticker_technicals_df}` where the `price` key relates to the pandas dataframe of historical ticker prices and the `technicals` key relates to the pandas dataframe of the technical indicator values associated with the historical ticker prices. I.E the `price` key refers to the data generated by the `update_ticker()` method and the `technicals` key refers to the data generated by the `update_timeseries_technicals()` method.

### `calc_rsi(data_series, period)`
This method ingests a pandas timeseries of values and calculates and returns a timeseries of RSI values that correspond to the values input. This is a helper method that is used in the `update_timeseries_technicals()` method to calculate the RSI column of the technicals dataframe.

The algorithm for calculating RSI in this manner was taken from Michal Vasulka's article on [computing RSI in python](https://tcoil.info/compute-rsi-for-stocks-with-python-relative-strength-index/).
